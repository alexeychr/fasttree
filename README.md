http://forum.dklab.ru/sql/php/IerarhicheskieStrukturiVBd.html

Вот, собственно, и класс. 

Прикладываю архив, в котором лежит библиотека и файлы, наглядно демонстрирующие её функциональность. Итак:
- /lib/fastttree.lib.php -- содержит: абстрактный класс fasttree_algorithm, в котором реализованы методы поиска ветвей; класс fasttree -- наследник fasttree_algorithm, который имплементирует методы для работы с конкретной БД
- /config.php -- константы для соединения с БД
- /index.php -- код, в котором наглядно продемонстрирована некоторая функциональность библиотеки
- /setup.php -- код, сканирующий C:/WINDOWS и заносящий структуру с базу

Вообще же следует заметить: fasttree_algorithm предназначен исключительно для поиска ветвей, но никак не для манипуляций с ними. 

Как пользоватся? Предположим, что у нас есть такая таблица:

```
CREATE TABLE IF NOT EXISTS cTree (
        id int UNSIGNED NOT NULL AUTO_INCREMENT,
        parent_id int UNSIGNED NOT NULL DEFAULT 0,
        file_name varchar(255) NOT NULL,

        PRIMARY KEY(id),
        KEY(parent_id),
        KEY(file_name)
)
```

Теперь мы забиваем эту таблицу содержимым папки WINDOWS, где file_name -- имя файла. 
И теперь, ежели мы хотим вывести содержимое директории /system, то мы пишем такой код:

```
//$DB -- какой-то указатель на бд
$tree = new fasttree(&$DB, "cTree", "file_name", "id", "parent_id");

//ежели мы хотим, чтобы результат был отсортирован, то можно указать следующее:
//$tree->DB_column_orderby = "file_name";

$result = $tree->getNodeChildrenByPath("/system", Array("file_name"), 1);
if($result == T_INVALID_PATH)
{
        echo "Invalid path: no such file or direcotory!";
}
else
{
        foreach($result as $item)
        {
                echo "<li>" . $item['file_name'] . "</li>";
        }
}
```

Всё! Мы получим содержимое только директории WINDOWS/system. Если поставить глубину выборки побольше (третий параметр метода getNodeChildrenByPath()), то мы так же получим и содержимое вложенных папок (напр., WINDOWS/system/COLOR).

Вообще же, README таков: 
1. Прочесть документацию по публичным методам класс fasttree_algorithm (это в файле /lib/fasttree.lib.php), там я всё детально рассмотрел, и с примерами 
2. Написать на основе класса fasttree свой собственный, в котором сделать три важных метода:
- query($query) -- отправка запроса $query в СУБД
- error($msg) -- обработчик ошибок в процессе работы класса
- fetch_array($resource) - метод, производятщий выборку результата БД по указанному ресурсу

Теперь некоторые интересные замечания (по большей степени -- касательно метода getNodeChildrenByPath(), потому что в нем реализован предложенный Д.Котеровым способ выборки и собственно ради него класс и писался): 

Во-первых, не стоит забывать про Foreign Keys :) 

Потом, принято, что для повышения скорости желательно разносить дерево на две таблицы: одна содержит лишь связи ID - parentID, в вторая -- данные, касающиеся самих ветвей. Однако в данном случае для метода etNodeChildrenByPath() это неприменимо, потому что он производит поиск по дополнительным данным, и если мы заставим его на сложных запросах ещё и "склеивать" эти две таблицы (я такое проверял), то скорость понизится раза в три. 

Кроме того, замечено, что скорость совершенно не зависит от количества элементов в пути (т.е. если мы хотим получить содержимое папки /1/2/3/4/5/6/7/8/9.., то скорость останется прежней). Зато она страшно зависит от глубины выборки, так что я бы не рекомендовал поднимать это значение выше 1. Если надо получить все-все элементы глубже заданного, то лучше идти рекурсивно (а если их просто надо удалить -- то тут foreign key и поможет). 

Наверное, всё. 
